@page.title: Parsing;
@page.author: Markdown;
@page.generated;


/* !!! DO NOT EDIT THIS PAGE !!!
   This page is auto-generated from doc/technical/parsing.md. Any changes will be overwritten
   the next time the page is generated. Instead, edit doc/technical/parsing.md directly.
*/

~sec [Parsing] {
    ~p {
        The wikifier source language is parsed hierarchically.
    }
    ~sec [Parsing stages] {
        ~p {
            The parsing process is divided into stages in the following order.
        }
        ~list {
            ~p {
                [[ [b]Master parser[/b] | #master-parser ]]\: Data is parsed character-by-character to
                separate it into several blocks. Additionally, variable definitions are handled,
                and comments are removed. Anything within a block (besides comments and other
                blocks) is untouched by the master parser.
            }
            ;
            ~p {
                [[ [b]Block parsers[/b] | ../blocks.md ]]\: Each block type implements its own parser
                which parses the data within the block. Block types can be hereditary, in which
                case they may rely on another block type for parsing. [[ Map | ../blocks.md#map ]] and
                [[ List | ../blocks.md#list ]] are the most common parent block types.
            }
            ;
            ~p {
                [[ [b]Formatting parser[/b] | ../language.md#text-formatting ]]\: Many block parsers make
                use of a formatting parser afterwards, the one which converts text formatting
                such as [c]\[b\][/c] and [c]\[i\][/c] to bold and italic text, etc. Values in
                [[ variable assignment | ../language.md#assignment ]] are also formatted.
            }
            ;
            
        }
        
    }
    ~sec [Master parser] {
        ~p {
            The master parser is concerned only with the most basic syntax\:
        }
        ~list {
            ~p {
                Dividing the source into [[ blocks | ../language.md#blocks ]]
            }
            ;
            ~p {
                Stripping [[ comments | ../language.md#comments ]]
            }
            ;
            ~p {
                [[ Variable assignment | ../language.md#assignment ]]
            }
            ;
            ~p {
                [[ Conditionals | ../language.md#conditionals ]]
            }
            ;
            
        }
        ~sec [Current] {
            ~p {
                Parser state information is stored in the [b]current[/b] object\:
            }
            ~p {
                | Key/Method            | Type/Arguments    | Description
                | -----                 | -----             | -----
                | [c]\{char\}[/c]              | Character         | current character
                | [c]\{next_char\}[/c]         | Character         | next character or an empty string if this is the last one
                | [c]\{last_char\}[/c]         | Character         | previous character or an empty string if this is the first one
                | [c]\{skip_char\}[/c]         | Boolean           | if set to true at any point, the next character will be skipped entirely
                | [c]\{line\}[/c]              | Integer           | current line number
                | [c]\{col\}[/c]               | Integer           | current column number (actually column + 1)
                | [c]->pos[/c]               | Position          | returns the current position as a hash
                | [c]->catch[/c]             | [[ Catch | #catch ]]   | fetch or set the current catch[nl]| [c]->clear_catch[/c]       |                   | close the current catch, returning to its parent
                | [c]->block[/c]             | [[ Block | ../language.md#blocks ]] | fetch or set the current block
                | [c]->is_comment[/c]        | Boolean           | true if we are currently inside a [[ block comment | ../language.md#comments ]]
                | [c]->mark_comment[/c]      |                   | increment the block comment level
                | [c]->clear_comment[/c]     |                   | decrease the block comment level
                | [c]->is_escaped[/c]        | Boolean           | true if the current character was escaped ([c]\{last_char\} eq '\\\\'[/c])
                | [c]->mark_escaped[/c]      |                   | mark the current character as escaped
                | [c]->clear_escaped[/c]     |                   | clear the escape state in preparation for the next character
                | [c]->is_ignored[/c]        | Boolean           | true if the current character is a master parser character
                | [c]->mark_ignored[/c]      |                   | mark the current character as ignored
                | [c]->clear_ignored[/c]     |                   | clear the ignored state in preparation for the next character
                | [c]->is_curly[/c]          | Boolean           | true if we are currently inside a [[ brace-escape | ../language.md#escaping ]]
                | [c]->mark_curly[/c]        |                   | increment the brace-escape level
                | [c]->clear_curly[/c]       |                   | decrease the brace-escape level
                | [c]->warning[/c]           | [c]$pos, $message[/c]  | push a parser warning at [c]$pos[/c] or the current position if unspecified
                | [c]->error[/c]             | [c]$message[/c]        | throw a fatal parser error. parsing of the document will be aborted
                | [c]->push_content[/c]      | [c]@content[/c]        | push the contents (mixed text/block) to the current catch at current position
                | [c]->push_content_pos[/c]  | [c]\\@content, \\@pos[/c] | push the contents (mixed text/block) to the current catch at provided positions
                | [c]->append_content[/c]    | [c]@content[/c]        | push or append the contents (mixed text/block) to the current catch
                | [c]->clear_content[/c]     |                   | purge all content and position information from the current catch
                | [c]->last_content[/c]      | String or [[ Block | ../language.md#blocks ]] | fetch or set the last element of the current catch content
            }
            
        }
        ~sec [Catch] {
            ~p {
                The parser pushes any content it encounters to the current catch. There is
                always a catch open\; at the start of a document, it is the main block. A
                [b]catch[/b] defines a location where content should be pushed along with other
                information about this location\:
            }
            ~p {
                | Key               | Type              | Description                                                       | Required?
                | -----             | -----             | -----                                                             | -----
                | [c]\{name\}[/c]          | String            | Type of catch                                                     | Yes
                | [c]\{hr_name\}[/c]       | String            | Human-readable description of the catch, used in warnings/errors  | Yes
                | [c]\{location\}[/c]      | Array reference   | Where content will be pushed                                      | Yes
                | [c]\{position\}[/c]      | Array reference   | Where position info will be pushed                                |
                | [c]\{parent\}[/c]        | Catch             | Catch we will return to when this one closes                      |
                | [c]\{valid_chars\}[/c]   | Compiled regex    | Characters that are allowed in the catch                          |
                | [c]\{skip_chars\}[/c]    | Compiled regex    | Characters that should be silently ignored                        |
                | [c]\{prefix\}[/c]        | Array reference   | [c]\[prefix, pos\][/c]\; prefix to be injected on skip_chars              |
                | [c]\{nested_ok\}[/c]     | Boolean           | True if we should allow the catch elsewhere than top-level        |
                | [c]\{is_block\}[/c]      | Boolean           | True for blocks so that we know to reset [c]$c->block[/c]              |
                | [c]\{is_toplevel\}[/c]   | Boolean           | True only for the main block                                      |
            }
            
        }
        
    }
    
}

